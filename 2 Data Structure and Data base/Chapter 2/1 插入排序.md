## 插入排序
形式上给出插入排序解决地问题的定义:

    输入: n个数的一个序列 <a1, a2, ..., an>
    输出: n个数的一个有序排列 <a1', a2', ..., an'> 满足 a1' <= a2' <= ... <= an'

## 1.1 算法伪代码
直觉上来说，插入排序的思路是，我们有一个有序区(当元素为1的时候显然有序), 我们将无序区的元素一个个地插入到这个有序区中，使得有序区仍然保持有序，当无序区为空，有序区就排序好了。

        INSERTION-SORT(A)
        for j = 2 to A.length   //  数组下标从1开始  
            key = A[j]  //  j是这一轮将要插入有序区的元素下标
            i = j - 1
            while i > 0 and A[i] > key
                A[i + 1] = A[i]
                i = i - 1
            A[i + 1] = key

## 1.2 循环不变式
在插入排序的例子中，每一轮迭代,A[1 : j-1] 是一个有序区, A[j+1 : n] 是还待排序的无序区, A[j]是这一轮需要插入有序区的元素. 事实上, A[1 : j-1] 的元素就是原来在位置1到j-1的元素，只是在之前的迭代中已经排序完毕！ 我们称A[1:j-1] 在迭代过程中保持的一些性质称为循环不变式,要作为循环不变式，需要满足三个条件:

1. **初始化**: 循环的第一次迭代之前为真
2. **保持**: 如果循环的某次迭代之前为真，那么下次迭代之前它仍然为真,也就是说，经过一次迭代，循环不变式保持性质为真。
3. **终止**: 在循环终止的时候，不变式应当为我们提供一个有用的性质来证明算法的正确性。

我们以插入排序为例:

**初始化**

具体地说，在使用for循环进行算法迭代地过程，我们认为在 将j赋值为2之后， 而在检测 j<= A.length 条件之前，是第一次循环迭代开始之前检查循环不变式的时刻。我们需要证明的两条循环不变式: (A[1..j-1] = A[1] 有序) and (A[1...j-1] = A[1] 实际上就是原本位置的元素) 平凡地成立。

**保持**

证明每次迭代保持循环不变式。 我们考察while循环, while循环中止的情况有两种:
1. i==0, 此时key与A[1...j-1]都进行了比较，且 key < A[1...j-1] 的所有元素, 跳出while循环后，我们将A[j]放到了放到了A[1]的位置上,因此仍然有序,且新的有序区A[1...j]的元素就是之前在这些位置上的元素！
2. A[i] =< key < A[i+1...j-1], 跳出while循环，我们将A[j]放在了A[i+1]的位置,而A[i+1...j-1]被整体向右搬移了一个位置,两条性质仍然成立。

**终止**

我们考察for循环停止的条件: j > A.length = n. 根据循环不变式，我们有A[1... j-1] = A[1...n] 有序，且这些元素就是原本位置上的元素，所以我们得到了原先n个元素的有序排列，算法正确。

## 2.1 算法分析
一般而言，算法所需要的时间和输入的规模n同步增长，因此我们通常把一个程序的运行时间描述成输入规模n的函数。

**输入规模**: 输入规模的概念具体地依赖于研究的问题，例如对排序问题，我们可以把排序的元素个数认为是输入规模，某个图类算法，我们可能会认为图的顶点数和边数为输入规模。

**运行时间**: 一个算法在特定输入上的运行时间是指执行的基本操作数或者步数,这个概念尽量独立于具体的机器。具体地说，执行每行伪代码需要常量的时间，尽管每行代码可能所需时间不同，我们选择假定第i行代码需要ci的时间。

## 2.2 插入排序算法的分析

        INSERTION-SORT(A)
        1 for j = 2 to A.length         c1      n    
        2    key = A[j]                 c2      n-1
        3    i = j - 1                  c3      n-1
        4    while i > 0 and A[i] > key c4      sum(t_j) j from 2 to n
        5        A[i + 1] = A[i]        c5      sum(t_j - 1) j from 2 to n
        6        i = i - 1              c6      sum(t_j - 1) j from 2 to n 
        7    A[i + 1] = k               c7      n-1
        
T(n) = $c_1n + c_2(n-1) + c_3(n-1) + c_4 \sum_{j=2}^nt_j + c_5 \sum_{j=2}^nt_j-1 + c_6 \sum_{j=2}^nt_j + c_7(n-1)$

当输入数组已经排好序,则$t_j$ 总为1，此时T(n) = an + b,是一个线性函数，常数因子依赖于代价常数c_i.

当输入数组方向有序,则 $t_j = j$, 此时$T(n) = an^2 + bn + c$ 是n的二次函数。

**讨论**

1. 最坏情况给算法运行时间提供了一个上界
2. 最好情况往往是不可靠的
3. 平均情况在量级上往往和最坏情况是一致的，有时候我们会在期望的概念下探讨平均情况下的算法运行时间
