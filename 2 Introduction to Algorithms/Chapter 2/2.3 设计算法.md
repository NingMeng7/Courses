## 2.3 设计算法

回想一下插入排序的算法，我们使用了**增量**的方法：也就是不断从无序区抽取一个元素，插入有序区的适当位置，使得增加一个元素后的有序区数组仍然有序。

下面是一个新的设计方法“分治法”，分治算法的优点之一是**分治算法的运行时间往往是容易确定的。**

### 2.3.1 分治法

一些结构上递归的算法典型地遵循分治法的思想，即，将问题分解成几个规模较小但类似于原问题的子问题，递归地求解这些问题，然后再合并这些问题的解来建立原问题的解。

**(1) 分解原问题为若干个子问题，这些子问题是原问题的规模较小的实例。**

**(2) 解决这些子问题，递归求解各个子问题，当子问题规模较小，直接求解。**

**(3) 合并这些子问题的解成原问题的解。**



### 2.3.2 归并排序合并算法

归并排序的关键步骤在于合并，我们调用MERGE(A, p, q, r) 来将两个已经排序好的A[p...q]、A[q+1...r] 子数组合并成一个有序的子数组A[p...r]



```c
MERGE(A, p, q, r)
    n1 = p - p + 1
    n2 = r - (q+1) + 1
    for i = 1 to n1
    	L[i] = A[p + i - 1]
    for j = 1 to n2
    	R[j] = A[q + 1 + j - 1]	//	先把A[p...q]、A[q+1...r]分别复制到L和R
    L[n1 + 1] = inf
    R[n2 + 1] = inf	//	inf哨兵使得我们不需要每次检测是子数组是否空了
    i = 1 
    j = 1
    for k = p to r
    	if L[i] <= R[j]
    		A[k] = L[i]
    		i = i + 1
        else
        	A[k] = R[j]
        	j = j + 1
```



### 2.3.3 循环不变式

我们选择这个属性：在最后一个for循环的每次迭代，子数组A[p...k-1]按从小到大的顺序包含L[1...n1+1]、R[1...n2+1]中的k-p个最小元素，L[i]、R[j]是各自所在数组中未被复制回数组A的最小元素。



初始化：循环第一次迭代之间，k = p, A[p...k-1]为空，k-p=0个L和R的最小元素，此时i=j=1，注意到L和R都有序的子数组，所以L[i]和R[j]是各自数组中未被复制回数组A的最小元素。

保持：

(1) 设在某一轮迭代之前，循环不变式成立，且L[i] <= R[j], L[i]是未被复制回数组A的最小元素，A[p..k-1]包含k-p个最小元素，因此在下一次迭代的时候，我们将会把未被复制回数组A的最小元素L[i]赋值给A[k], 此时子数组A[p...k] 包含k-p+1个最小元素。 更新i 和 k后，A[p...k]包含k-p个最小元素，而L[i]是L中未被复制回的最小元素(如果正好是无穷了，就不是未被复制回的元素了，它也不会满足if条件)

(2) 类似地可以证明 L[i] > R[j]的情况。

终止：

当 k = r + 1，子数组A[p...k-1]包含有L和R中的k-p个最小元素，也就是 r - p + 1个最小元素，又每次插入A的都是当前未被复制回数组A的最小元素，因此此时A就是合并两个子数组后的有序数组。



### 2.3.4 归并排序

```c
MERGESORT(A, p, r)
    if p < r
    	q = (p+r)/2  //  向下取整的整数除法
    	MERGESORT(A, p, q)
        MERGESORT(A, q+1, r)
        MERGE(A, p, q, r)
```



一个分治法的算法可以递归地分析，假设T(n)是规模为n的一个问题所需要的时间，当规模小于等于一个常量c的时候，我们认为问题可以在常数时间内被解决，每轮递归将问题分成a个子问题，每个子问题的规模是原问题的1/b，分解需要时间D(n)，合并需要时间C(n).


$$
T(n) = \begin{cases}
\Theta(1) \quad n \leq c \\
aT(n/b) + D(n) + C(n) \quad others
\end{cases}
$$
**以归并排序为例**
$$
T(n) = \begin{cases}
\Theta(1) \quad n = 1 \\
2T(n/2) + \Theta(1) + \Theta(n) \quad n>1
\end{cases} \\
归并排序的T(n)为 \Theta(nlgn) \quad lgn =log_2n
$$
