## Chapet 3 程序的机器级表示

### 0. Introduction 

计算机执行机器代码，用字节序列编码低级的操作：manipulate data, manage memory, read and write data on storage devices and communicate over networks. 

通常编译器基于编程语言的规则、目标机器的指令集和操作系统遵循的惯例，经过一系列阶段生成机器代码，机器码是难以阅读的，对程序员而言，通常我们阅读和理解使用助记符的汇编代码。



With modern optimizing compilers, the generated code is usually at least as efficient as what a skilled assembly-language programmer would write by hand. Best of all, a program written in a high-level language can be compiled and executed on a number of different machines, whereas assembly code is highly machine specific.



学习机器代码(学会阅读和理解汇编的几个理由)

1. 阅读汇编代码，能够让我们理解编译器的优化能力，分析代码中隐含的低效率。
2. 部分代码信息在机器级的代码是可见的，而更高级的语言会隐藏这些细节。
3. 部分程序遭受攻击的方式，涉及到程序存储运行时控制信息的方式的细节。

### 3.1 程序编码

gcc -og -o p p1.c p2.c 

其中 -og 告诉编译器生成符合原始C代码整体结构的机器代码的优化等级。

#### 3.2.1 Machine-Level Code

Being able to understand assembly code and how it relates to the original C code is a key step in understanding how computers execute programs. 

Most **instruction set architectures(ISAs)**, including x86-64, describe the behavior of a program as if each instruction is executed in sequence, with one instruction completing before the next one begins. 

1. The processor hardware is far more elaborate, executing many instructions concurrently, but it employs safeguards to ensure that the overall behavior matches the sequential operation dictated by the ISA.
2. The memory addresses used by a machine-level program are virtual addresses, providing a memory model that appears to be a very large byte array.

**The machine code for x86-64 differs greatly from the original C code. Parts of the processor state are visible that normally are hidden from the C programmer.**

- The program counter(PC) indicates the address in memory of the next instruction to be executed.
- The integer register file contains 16 named locations storing 64-bit values. These register can hold addresses(~ C pointer ) or integer data. Some registers are used to keep track of critical parts of the program state, while others are used to hold temporary data.
- The condition code registers hold status information about the most recently executed arithmetic or logical instruction.
- A set of vector registers can each hold one or more integer or floating-point values.

**The macine code views the memory as simply a large byte-addressable array!** Whereas C provides a model in which objects of different data types can be declared and allocated in memory, machine code views the momory simply a large byte-addressable array. Aggregate data types in C such as arrays and structures are represented in machine code as contiguous collections of bytes! The assembly code makes no distinctions between signed or unsigned integers, between different types of pointers, or even between pointers and integers!



Typically, programs will only have access to a few megabytes, or perhaps several gigabytes.**The operating system manages the virtual address space, translating virtual addresses into the physical addresses of values in the actual processor memory.**



### 3.2.2 Code Examples

A key lesson to learn from this is that the program executed by the machine is simply a sequence of bytes encoding a series of instructions.

**disassembler**: machine code -> assembly-code

Several features about machine code and its disassembled representation are worth noting:

- x86-64 的指令长度从1-15个字节不等，常用字节以及操作数较少的指令字节数少。
- 设计指令格式的方式是，从某个给定的位置开始，可以将字节唯一地解码成指令。
- 反汇编器只是基于机器代码文件中的字节序列来确定汇编代码，不需要访问程序的源代码或者汇编代码。
- 反汇编器使用的指令命名规则与GCC生成的汇编代码使用的有些微的差别。

### 3.2.3 Notes on Formatting

The assembly code generated by GCC is difficult for a human to read. One one hand, it contains information with which we need not to be concerned, while on the other hand, it does not provide any description of the program or how it works.

**All of the lines beginning with '.' are directives to guide the assembler and linker. We can generally ignore these.**

### 3.3 Data Formatting

There are some features of a machine that cannot be accessed by a C program. For example, the C programs can never deteremine the value of FLAG(PSW) Register. There are two ways to incorporate assembly code into C programs.

1. we can write an entire function as a separate assembly-code file and let the assembler and linker combine this this the C progrom file.
2. We can use the **inline assembly** feature of GCC,where brief sections of assembly code can be incorporated into a C program using the asm directive. This approach has the advantage that it minimizes the amount of machine-specific code.

由于汇编代码是机器相关的，所以只有某种特性必须要用这种方式才能访问的时候，才使用以上两种方式之一。

### 3.4.1 Operand Specifiers

| Type      | Form         | Operand value        | Name              |
| --------- | ------------ | -------------------- | ----------------- |
| Immediate | $Imm         | Imm                  | Immediate         |
| Register  | r_a          | R[r_a]               | Register          |
| Memory    | Imm          | M[Imm]               | Absolute          |
| Memory    | (r_a)        | M[R[r_a]]            | Indirect          |
| Memory    | Imm(r_b)     | M[Imm+R[r_b]]        | Base+displacement |
| Memory    | (rb,ri)      | M[R[rb]+R[ri]]       | Indexed           |
| Memory    | Imm(rb,ri)   | M[Imm+R[rb]+R[ri]]   | Indexed           |
| Memory    | (,ri,s)      | M[R[ri]·s]           | Scaled indexed    |
| Memory    | Imm(,ri,s)   | M[Imm+R[ri]·s]       | Scaled indexed    |
| Memory    | (rb,ri,s)    | M[R[rb]+R[ri]·s]     | Scaled indexed    |
| Memory    | Imm(rb,ri,s) | M[Imm+R[rb]+R[ri]·s] | Scaled indexed    |

s 必须是 1、2、4或者8

### 3.4.2 Data Movement Instructions

For most cases, the MOV instructions will only update the specific register bytes or memory locations indicated by the destination operand. **The only exception is that when movl has a register as the destination, it will also set the high-order 4 bytes of the register to 0.**



**3.4.3 A data movement example**

​	

```
// C code
long exchange(long *xp, long y)
{
    long x = *xp;
    *xp = y;
    return x;
}

; Assembly code
exchange:
	movq (%rdi), %rax
	movq %rsi, (%rdi)
	ret
```

Two features about this assembly code are worth noting.

1. We see that what we call "pointer" in C are simply addresses.
2. Local variables such as x are often kept in registers rather than stored in memory locations. Register access is much faster than memory access.

```
;  Assembly code
;  xp,yp, and zp are stored in registers %rdi, %rsi, and %rdx, respectively
decode1:
	movq (%rdi), %r8
	movq (%rsi), %rcx
	movq (%rdx), %rax
	movq %r8, (%rsi)
	movq %rcx, (%rdx)
	movq %rax, (%rdi)
	ret
	
//  C code
void decode1(long *xp, long *yp, long *zp)
{
    long x = *xp;
    long y = *yp;
    long z = *zp;
    *yp = x;
    *zp = y;
    *xp = z;
}
```

**3.4.4 Pushing and Popping Stack Data**

Stack plays a vital role in the handling of procedure calls. A stack is a data structure where values can inserted and removed from one end of the array according to the "lasi-in, first-out" discipline.

**The stack grows downward such that the top element of the stack has the lowest address of all stack elements.**

The end of the array where we add or delete elements is called the top of the stack. 栈顶拥有最低的地址，因为push总是先减地址，再压栈！

Pushing a quad word value onto the stack involves first decrementing the stack pointer by 8 and then writing the value at the new top-of-stack address.

### 3.5 Arithmetic and Logical Operations

Most of the operations are given as instruction classes, as they can have different variants with different operand sizes.(Only leaq has no other size variants).

The operations are divided into four groups: load effective address, unary, binary, and shifts.



**3.5.1 Load effective address**

1. The instruction copies the effective address to the destination!
2. **Leaq instruction can perform addition and limited forms of multiplication.**
3. The destination operand must be a register



```c
//  C code
long scale(long x, long y, long z)
{
    long t = x + 4 * y + 12 * z;
    return t;
}

;  Assembly code
;  x, y, z in %rdi, %rsi, %rdx respectly
scale:
	leaq (%rdi, %rsi, 4), %rax
	leaq (%rdx, %rdx, 2), %rdx
	leaq (%rax, %rdx, 4), %rax
	ret

```

**3.5.2 Unary and Binary Operations**

Unary operation: the single operand serving as both source and destination.

Binary operation: the second operand is used as both a scoude and a destination. **The source operand is given first.**

**3.5.3 Shift Operations**

The different shift instructions can specify the shift amount either as an immediate value or with the single-byte register %cl. **These instructions are unusual in only allowing cl as the operand!**

**With x86-64, a shift instruction operating on data values that are w bits long determines the shift amount from the low-order m bits of %cl, where 2^n = w!!**

```c
// C code
long arith(long x, long y, long z)
{
    long t1 = x ^ y;
    long t2 = z * 48;
    long t3 = t1 & 0x0F0F0F0F;
    long t4 - t2 - t3;
    return t4;
}

; Assembly code
; x, y, z in %rdi, %rsi, %rdx respectly
arith:
	xorq %rsi, %rdi
	leaq (%rdx, %rdx, 2), %rax
	salq $4, %rax
	andl $252645135, %edi
	subq %rdi, %rax
	ret
```

**Most of the instructions above can be used for either unsigned or two's-complement arithmetic. Only right shifting requires instructions that differentiate between signed versus unsigned data. This is one of the features that makes two's-complement arithmetic the preferred way to implement signed integer arithmetic.**

