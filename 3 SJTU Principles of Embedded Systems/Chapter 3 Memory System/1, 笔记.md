## Chapter 3 Memory system

### 3.1 存储器的分类
### 3.1.1 RAM: Random Access Memory
CPU能根据RAM的地址将数据随机地(对任意地址访问都是O(1)时间)写入或者读出,但是掉电之后所存的数据会全部丢失。

静态RAM(SRAM): 边沿敏感的触发器,速度非常快,只要电源存在内容就不会消失,但是比较昂贵

动态RAM(DRAM): 用电容带电与否来表示二进制的0/1,DRAM存在泄漏电流,必须周期性刷新

### 3.1.2 ROM: Read Only Memory

ROM是一种非挥发性的存储器, 且只能读取数据不能写入数据,用于存储计算机中一些固定信息,例如计算机的启动程序, 在计算机工作的过程中ROM中的内容不能修改。
ROM(掩模型)

PROM(熔丝式、可编程型)

EPROM(可擦除可编程)

EEPROM(电可擦除可编程)

## 3.2.1 存储芯片与容量

将大量的存储单元合起来可以构成一个存储单元阵列，存储大量的信息，一般在存储器芯片中包括存储体、读写电路、地址译码器和控制电路等组成部分。 

其中地址译码器的输入信号线是访问存储器是地址编码, 它将二进制代码形式的地址转换成驱动读写操作的选择信号! 因此,**从电路识别某个芯片的地址，应当根据使能信号写出地址代码,进而得到地址。**

1. 单译码方式: 只用一个译码电路,将所有的地址信号转换成行选通信号，在一行内的各存储单元构成一个数据字，每一列对应一个数据位。这种方式适用于容量较小的存储器芯片。

2. 双译码方式: 将存储单元构成一个方阵, 外部输入的地址线分成行地址和列地址两部分,地址译码器分别产生行选通信号和列选通信号,aij将被选中。

选通信号线要驱动大量的存储单元，所以应当在译码器后边加一个驱动器,用驱动输出的信号去驱动连接在各选通线上的存储单元。

一块8K X 8 的存储器芯片指的是,具有8K个地址，每个地址是一个8 bit 的单元. 其中,前者代表地址容量,后者代表数据线(D)的宽度.

## 3.3.1 存储系统的构成
存储器与CPU的连接包括地址线的连接、数据线的连接以及控制线的连接，在访存的过程中，CPU向存储器提供地址信息, 因此地址线的单向的，而数据线是双向的。 通常，一个存储器芯片不能满足计算机存储器的字数和数据宽度的要求，需要对存储器芯片进行: 位扩展/字扩展/字位扩展。

> 1. 位扩展

当存储器的地址容量足够,而数据宽度不够,需要进行位扩展,在位扩展中,各存储器芯片采用相同的地址信号,各存储器芯片的数据线分别连接到CPU数据总线的相应位,其余的使能信号连接也完全相同，所有的芯片在同一个控制器下同时进行相同的操作, 整个存储器的字数不变(和每个存储器芯片相同), 位数是存储器芯片的位数之和。

> 2. 字扩展

当存储器的数据宽度足够，但是地址容量(字数)不足,需要进行字扩展, 具体地说,添加高位地址进行片选, 而各个存储芯片的低位地址完全一样,每次访存只有一个存储器芯片进行读写操作, 字扩展扩大了存储器的空间容量。

> 3. 字位扩展

当存储器既需要在数据宽度上扩展，又需要增大容量的适合,就需要进行字位扩展, 首先对存储器进行位扩展, 得到足够位数的基本单元,然后对每个位扩展后的模块进行字扩展,完成字位扩展。 设采用的存储器芯片容量是 m x n, 组成 M x N 的存储器, 则需要的芯片数是: (M x N) / (m x n)

此外,在考虑所需要的地址线的时候，有字寻址和字节寻址的差别，要实现字节寻址，在每个存储单元之间还应当有内部字节寻址的地址信号位。

## 3.2.2 全译码与部分译码

> 全译码

所有CPU的高位地址线均参与对存储单元的译码寻址

低位地址线对芯片内各存储单元译码寻址(片内译码)

高位地址线对存储芯片译码寻址(片选译码)

每个存储单元的地址都是唯一的,不存在地址重复

> 部分译码

部分高位地址线参与对存储单元的译码寻址

存在地址段内容重叠(每个单元有多个地址

## 3.3 存储器的层次结构
将不同速度及容量的存储分层级从而得到效率与成本之间较好的平衡, 每一级的存储层次都是上一级与下一级的 "Cache", 用以弥补二者在速度上的差异。 上一层次的存储器比其下一层次的容量小、速度快、每字节存储容量的成本更高。

这种分层级的存储器结构的一大理由是,根据统计规律:

1. 时间局部性: 如果一个存储单元被访问, 则可能这个存储单元会很快再次被访问。
2. 空间局部性: 如果一个存储单元被访问, 则它邻近的单元可能很快被访问。

因此，我们可以将计算机中频繁访问的数据存放在层次较高的存储器,而将不频繁访问的数据存放在速度较慢，但是容量较大，成本较低的存储器层次中！

## 3.3.1 高速缓冲存储器-Cache

实际的计算机系统中,CPU的工作速度很快，对于存储器的速度和容量要求较高，而寄存器容量较小，主存存取速度太慢，因此需要采用层次化的存储器系统结构: 将计算机中频繁访问的数据放在速度较高的存储器中，将不频繁访问的数据存放在速度较慢但是容量较大，价格较低的存储器中

Cache是一个高速小容量的临时存储器，用高速的SRAM芯片实现或者集成到CPU芯片的外部，用以弥补CPU与主存在速度上的差异

## 3.3.1 Cache的基本概念

1. 在带Cache的计算机中，最开始Cache中是没有数据或者程序代码的，当CPU访问存储器时，从主存中读取的数据或者代码在写入Registers的同时也写入Cache
2. 在以后的访问中，如果访问的数据或者代码已经存在于Cache中，就可以直接从Cache中访问而不必再到主存去访问，这个情况叫做**Cache命中**
3. Cache命中的统计概率称为**Cache的命中率**
4. 反之，访问主存的数据或者代码不存在于Cache中的情况就称为不命中或者失效,不命中的统计概率称为**失效率**
5. 为了提高命中率，一般在将数据写入Cache的时候，把该数据前后相邻的数据或者代码也一起写入Cache中，**从主存到Cache的数据传送是以块为单位进行的**,符合访存的局部性规律
6. 访问时间 = Cache访问时间 = 命中时间
7. 访问时间 = 命中时间 + 失效访问时间(因访问主存而增加的访问时间 
8. 无论Cache是否命中, Cache都是必须要访问的

## 3.3.2 Cache设计时需要考虑的问题

- 地址影像
    
    主存中的块放入Cache中的什么地方？这是一个主存地址映像到Cache地址的问题，映像以块为单位。

- 替换策略

    Cache放满了，用什么替换策略来实现数据更替。

- 更新策略
    
    写Cache的时候是否写主存，什么时候将数据写入Cache，说明时候将数据写入主存

- 容量问题

    Cache的容量比主存低很多，数据块怎么分配

## 3.3.2.1 地址映像与变换
1. 直接映像
    一个主存块映像到Cache中的唯一位置，根据主存块号在块表中查询出区号，与主存区号比较，相同则命中。
    
    (a) 设Cache块号为0~N-1,主存还需要分为M个区，每个区内有0~N-1标号的块。
    
    (b) 主存中每个块能被映射到Cache的块是确定的，例如0区0块,1区0块,...,M区0块都只能映射到0块，冲突的可能性较大，Cache的存储空间得不到充分利用

    例如: 假定Cache的块容量是8,访问的块地址序列:
    10110、11010、10110、11010、10000、10010,地址的低三位作为Cache的块号，高两位作为区号标志位

    例题:

    设有一个cache的容量为2K字，每个块为16字，

    (1) 该cache可容纳多少个块？ 

    (2) 如果主存的容量是256K字，则有多少个块？ 

    (3) 主存的地址有多少位？cache地址有多少位？ 

    (4) 在直接映像方式下，主存中的第i块映像到cache中哪一个块中？ 

    (5) 进行地址映像时，存储器的地址分成哪几段？各段分别有多少位？ 

    (1) cache中有2048/16=128个块。 

    (2) 主存有256K/16=16384个块。 

    (3) 主存容量为256K=218字，字地址有18位。 cache容量为2K=211字，字地址为11位。 

    (4) 在直接映像方式下，主存中的第i块映像到cache中第 i mod 128个 块中。 

    (5) 区号7位，块号为7位，块内字地址为4位(128*128=16384)
2. 全相联映像
    
    每个内存块都可以映像到Cache任何一个块的映像方式。

    根据主存块号在块表中检索，如果存在，则命中,问题是查询整个Cache消耗太大
    
3. 组相联映像
   将存储空间分为若干个组，每个组中含有若干的块，主存中的一个数据块可以装入Cache中同一个组的任意一个块。即**各组之间直接映像,组内各块之间是全相联映像**

## 3.3.2.2 替换策略与更新策略

替换策略

1. 随机法：用随机数产生电路产生一个随机替代块号，不符合访存局部性规则
2. FIFO，不符合访存局部性规则
3. 近期最少使用法：较好地利用了访存局部性原理
4. 近期最久未使用法

更新策略

- Cache命中的时候
1. 写直达法
2. 写回法

- Cache失效的时候
1. 按写分配法
2. 不按写分配法

# 3.4 虚拟存储器

- 虚拟存储器是存储器组织中的一个重要概念，采用虚拟存储器之后，实际上计算机在访问存储器的时候不是直接根据程序员指定的地址进行的。
- 存储系统将程序员指定的地址转换为可在存储器中访问的地址，即，程序指令生成的地址是虚拟地址(逻辑地址)，转换得到实际地址(物理地址).
- 这种虚拟地址与实际地址之间的映射关系使得可以根据需要动态改变。
- 虚拟地址不仅可以映像到内存的存储空间(物理地址)，也能映像到外存(磁盘)的存储空间。

## 3.4.2 虚拟存储器的作用

• 分隔地址空间 – 通过将不同用户的程序的逻辑地址空间转换成不同的物理地址空 间，系统可将用户程序的存储空间相互隔离，从而保护存储空间。 – 使得每个用户进程之间可以实现存储空间的互相隔离和有限制的 共享。 

• 解决主存的容量问题 – 要求在不明显降低平均访问速度的前提下增加程序的访存空间。 – 使用磁盘（硬盘）等外存来构成运行中所需要的程序和数据存储 空间，使得虚拟地址能够映像到磁盘的存储空间。 – 在将磁盘的存储区域移到内存中后，就使得程序能像访问内存一 样访问外存。 

• 程序的重定位 – 程序使用的虚拟地址可映射到不同的物理地址，使得程序能够装 入到主存中的任意位置。

# 3.4.3 虚拟存储器

- 不明显降低访存速度，且使存储系统具有外存的容量

将虚拟空间地址中访问最频繁的一部分地址范围映射到主存，其余的地址空间映射到外存，这样程序员的角度来看，存储空间变大了

当程序要访问的存储单元映射到主存的空间的时候，存储系统将虚拟地址转换成主存的实际地址

如果虚拟地址对应的存储单元在外存中，不能直接形成物理地址，存储系统先把要访问的空间映射到主存，并将这个存储单元从外存调入内存，然后改变映射关系，进行地址转换之后对数据访问

虚拟存储器主要是由软件进行管理的，而 Cache是由硬件管理的。 

– Cache的替换策略是由硬件实现的，而虚拟存储器 的替换策略主要是由操作系统实现的。 

– 虚拟存储器中一般使用全相联地址映射方式以提高 命中率。 

– Cache的存在及其所有的操作对程序员一般是透明 的，虚拟存储器中数据在主存与外存之间的传输对 系统程序员是不透明的，而对应用程序员和用户是 透明的。 

– 虚拟存储器的存储空间大小受到计算机地址空间的 限制；而Cache的容量以及主存的容量一般远小于 CPU的地址空间，因而不存在这种限制
