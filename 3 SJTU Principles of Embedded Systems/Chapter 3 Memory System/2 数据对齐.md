## 1. 概述
我们知道存储器的基本单元是一个byte, 每个byte有一个唯一的物理地址, 具体存放数据的时候，不同数据可能会有不同的长度(例如int 和 double的长度就不同), 在访问特定变量的时候, 为了提高访问效率, 要求数据在内存空间上的排列有一定的规则, 这就是对齐。

当 len(Data) % address(Data) == 0, 则数据是对齐的。 例如, 如果int是4个字节的,那么地址4,8,200,2000 都是对齐的, 而3，7，9就不是对齐的

## 2. 为什么要数据对齐
最常见的一个原因是，如果不对齐，在存取效率上会有损失，以8086为例子，具体地说, 8086的一个字在存储器中以相邻的两个字节存放, 存入的时候低位字节在低地址，高位字节在高地址。 一个字可以从偶地址开始存放,也可以从奇地址开始存放, 但是8086访问存储器都是以字为单位进行访问，并且从偶地址开始！ 如果字单位的地址从偶地址开始, 只需要访问一次存储器, 而字单位的地址从奇地址开始，CPU就需要访问两次存储器。

## 3. 怎么实现数据对齐
1. 通常,编译器会替我们选择适合目标平台的对齐策略
2. 我们也可以通知给编译器传递预编译指令而改变对指定数据的对齐方法。

## 4. 一些例子

1 某计算机存储器按照字节编址，采用小端方式存储数据，假定编译器规定int和short型长度分别为32位和16位，并且数据按照边界对齐存储。 某C语言的程序段如下：
		 
		 struct {
    		int a;
    		char b;
    		short c;
		} record;
		record.a = 273;


若record变量的首地址为0xC008,则地址0xC008的内容以及record.c的地址分别为： 

A. 0x00、0xC00D 

B. 0x00、0xC00E 

C. 0x11、0xC00D 

* D. 0x11、0xC00E

首先hex(273) = 111H, 由于采取小端方式，则最低字节存放最低位

0XC008: 11H

0XC009: 01H

0XC00A: 00H

0XC00B: 00H

0XC00C: char b

0XC00D: 留白 // 这是为了short对齐

0XC00E: short

0XC00F: short

